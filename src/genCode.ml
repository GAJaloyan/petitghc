module C = Closured
module F = Format
open Mips

(* a label generated by the compiler is of the forme bi where i is an integer 
 * getNextLabel () returns the next free label *)

let nextNbLabels = ref 1

let getNextLabel () =
   incr nextNbLabels;
   "l" ^ (string_of_int !nextNbLabels)

let (genv : (string, string) Hashtbl.t) = 
   let rep = Hashtbl.create 42 in
   Hashtbl.add rep "force" (getNextLabel ());
   Hashtbl.add rep "div" (getNextLabel ());
   Hashtbl.add rep "rem" (getNextLabel ());
   Hashtbl.add rep "error" (getNextLabel ());
   Hashtbl.add rep "putChar" (getNextLabel ());
   rep

let addLabel x =
   if not (Hashtbl.mem genv x) then
     Hashtbl.add genv x (getNextLabel ())

let getLabel = Hashtbl.find genv 

let force = getLabel "force"

let forceGen () =
   (* force forces the evaluation of the value
    * contained inside a1 *)
   let force_1 = getNextLabel () and force_2 = getNextLabel () in
   comment "start force" ++
   label force ++
   lw t0 areg (0,a0)++
   li t1 2 ++
   bgt t0 t1 force_1 ++
   jr ra ++
   
   label force_1 ++
   li t1 3 ++
   beq t0 t1 force_2 ++
   lw a0 areg (4,a0) ++
   jr ra ++

   label force_2 ++
   push ra ++
   push a0 ++
   lw a1 areg (4,a0) ++
   lw t0 areg (4,a1) ++
   jalr t0 ++
   move a0 v0 ++
   jal force ++
   pop a1 ++
   sw a0 areg (4,a1) ++
   li t0 4 ++
   sw t0 areg (0,a1) ++
   pop ra ++
   jr ra ++
   comment "end force"
   ,
   nop

let putCharGen () =
   let putCharFun = getNextLabel () in
   let putCharClos = getNextLabel () in
   (* prints the character inside $a0, it ignores $a1:
    * it is the function associated with putChar's closure *)
   (comment "start putChar" ++
   label putCharFun ++
   push fp ++
   push ra ++
   push a0 ++
   push a1 ++
   jal force ++
   li v0 11 ++
   lw a0 areg (4, a0) ++
   syscall ++
   pop a1 ++
   pop a0 ++
   pop ra ++
   pop fp ++
   jr ra ++
   comment "end putChar"),
   (
   label (getLabel "putChar") ++
   dword [3] ++
   address [putCharClos] ++
   label putCharClos ++
   comment "putChar closure" ++
   dword[2] ++
   address [putCharFun])

let errorGen () =
   let errorFun = getNextLabel () in
   (
     let printChar = getNextLabel () in
     comment "start error" ++
     label errorFun ++
     lw t0 areg (0, a0) ++
     beqz t0 printChar ++
     li v0 17 ++ (* exit2 systemcall *)
     li a0 1 ++
     syscall ++
     label printChar ++
     move t0 a0 ++
     lw a0 areg (4,t0) ++
     li v0 11 ++
     syscall ++
     lw a0 areg (8,t0) ++
     j errorFun ++
     comment "end error"
   ),
   (label (getLabel "error") ++
   dword [2] ++
   address [errorFun])

(* op is from mips module: div or rem *)
let opGen op () =
   let fun1 = getNextLabel () in
   let fun2 = getNextLabel () in
   (
      comment ("start " ^ op) ++
      label fun1 ++
      push a0 ++
      li a0 12 ++
      li v0 9 ++
      syscall ++
      pop a0 ++
      li t0 2 ++
      sw t0 areg (0,v0) ++
      la t0 alab fun2 ++
      sw t0 areg (4,v0) ++
      sw a0 areg (8,v0) ++
      jr ra ++

      label fun2 ++
      jal force ++ (* evaluates the second argument *)
      push a0 ++
      lw a0 areg (0,a1) ++ (* gets the first argument *)
      jal force ++
      pop a1 ++
      (match op with "div" -> div | "rem" -> rem
                   | _ -> failwith "impossible case") v0 a1 oreg a0 ++
      jr ra ++
      comment ("end " ^ op)
   ),
   (label (getLabel op) ++
   dword [2] ++
   address [fun1])

let baseFunctions () =
   List.fold_left (fun (code,data) f ->
      let code',data' = f () in
      (code ++ code'), (data ++ data')
   )
   (nop,nop)
   [forceGen; putCharGen; errorGen; opGen "div"; opGen "rem"]

let rec compile_expr = function
 | C.Evar v -> 
     begin match v with
     | C.Vglobal x -> la v0 alab (getLabel x)
     | C.Vlocal i ->
        lw v0 areg (i, fp)
     | C.Vclos n ->
        lw v0 areg (n, a1)
     | C.Varg -> 
        move v0 a0 (* the current functions argument is in a0 *)
     end
 | C.Eclos (f,vs) ->
     comment ("startclos" ^ f) ++
     push a0 ++
     li a0 (4*((List.length vs) + 8)) ++
     li v0 9 ++
     syscall ++
     la t0 alab (getLabel f) ++
     sw t0 areg (4,v0) ++
     li t0 2 ++
     sw t0 areg (0,v0) ++
     fst (
       List.fold_left 
       (fun (acc,posClos) v ->
        (acc ++
         (match v with
         | C.Vglobal x -> la t0 alab (getLabel x)
         | C.Vlocal n  -> lw t0 areg (n, fp)
         | C.Vclos n   -> lw t0 areg (n, a1)
         | C.Varg      -> move t0 a0
        ) ++ sw t0 areg (posClos, v0)),
        (posClos+4)
       )
       (nop,8)
       vs) ++
     pop a0 ++
     comment ("endClos" ^ f)
 | C.Eapp (e1,e2) ->
     (* should be good *)
     let code_e1 = compile_expr e1
     and code_e2 = compile_expr e2 in
     comment "start app" ++
     push ra ++
     push a0 ++
     push a1 ++
     code_e1 ++
     move a0 v0 ++
     jal force ++
     push a0 ++
     code_e2 ++
     move a0 v0 ++
     jal force ++
     pop a1 ++
     lw t0 areg (4,a1) ++
     jalr t0 ++
     pop a1 ++
     pop a0 ++
     pop ra ++
     comment "end app"
 | C.Ethunk e -> (* according to the preceding module, e will always
                    be a closure *)
     (* should be good *)
     let code_e = compile_expr e in
     comment "start thunk" ++
     code_e ++
     move t0 v0 ++
     li a0 8 ++ (* allocates 2 places in memory *)
     li v0 9 ++
     syscall ++
     sw t0 areg (4,v0) ++
     li t0 3 ++
     sw t0 areg (0,v0) ++
     comment "end thunk"
 | C.Elet (bs,e) ->
     (List.fold_left
       (fun acc (i,e') ->
          acc ++
          compile_expr e' ++
          sw v0 areg (i,fp))
       nop
       bs) ++
     compile_expr e
 | C.Eif (e1,e2,e3) ->
     let code_e1 = compile_expr e1
     and code_e2 = compile_expr e2
     and code_e3 = compile_expr e3 in
     let else_lab = getNextLabel () and endif_lab = getNextLabel () in
     code_e1 ++
     lw t0 areg (4,v0) ++
     beqz t0 else_lab ++
     code_e2 ++
     j endif_lab ++
     label else_lab ++
     code_e3 ++
     label endif_lab (* v0 already contains the good value *)
 | C.Ecase (e1,e2,i1,i2,e3) -> failwith "undefined"
 | C.Edo es ->
     let ces = List.map compile_expr es in
     List.fold_left (fun acc x -> acc ++ x) nop ces
 | C.Ereturn -> nop
 | C.Eneg e ->
     let code_e = compile_expr e in
     code_e ++
     move a0 v0 ++
     jal force ++
     li t0 0 ++
     sub v0 t0 oreg a0
 | C.EbinOp (e1,o,e2) when o <> C.Colon -> 
     let code_e1 = compile_expr e1 in
     let code_e2 = compile_expr e2 in
     push a0 ++
     push a1 ++
     code_e1 ++
     move a0 v0 ++
     jal force ++
     move a1 a0 ++ (* first argument in a1 *)
     code_e2 ++
     move a0 v0 ++
     jal force ++
     move a0 a1 ++
     (match o with
     | C.Plus -> add v0 a1 oreg a0
     | C.Minus -> sub v0 a1 oreg a0
     | C.Time -> mul v0 a1 oreg a0 
     | C.LowerEq -> sle v0 a1 a0
     | C.GreaterEq -> sge v0 a1 a0
     | C.Greater -> sgt v0 a1 a0
     | C.Lower -> slt v0 a1 a0
     | C.Unequal -> sne v0 a1 a0
     | C.Equal -> seq v0 a1 a0
     | C.And -> and_  v0 a1 a0
     | C.Or -> or_ v0 a1 a0
     | _ -> failwith "impossible"
     ) ++
     pop a1 ++
     pop a0
 | C.Etrue ->
     push a0 ++
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 1 ++
     sw t0 areg (4,v0) ++
     li t0 0 ++
     sw t0 areg (0,v0) ++
     pop a0
 | C.Efalse ->
     push a0 ++
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 0 ++
     sw t0 areg (4,v0) ++
     li t0 0 ++
     sw t0 areg (0,v0) ++
     pop a0
 | C.Eint n ->
     push a0 ++
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 n ++
     sw t0 areg (4,v0) ++
     li t0 0 ++
     sw t0 areg (0,v0) ++
     pop a0
 | C.Echar c ->
     push a0 ++
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 (Char.code c) ++
     sw t0 areg (4,v0) ++
     li t0 0 ++
     sw t0 areg (0,v0) ++
     pop a0
 | C.EemptyList ->
     push a0 ++
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 0 ++
     sw t0 areg (4,v0) ++
     li t0 0 ++
     sw t0 areg (0,v0) ++
     pop a0

and compile_decl (code,data) = function
 | C.Let (x,fun_) ->
     code
     ,
     (let closure = getNextLabel () in
     data ++ (* the thunk associated with the let *)
     label (getLabel x) ++
     dword [3] ++
     address [closure] ++
     label closure ++ (* the closure associated with it *)
     dword [2] ++
     address [getLabel fun_])
 | C.Letfun (x,e,fpmax) -> (* x is the name of the function
                        and e is the expression corresponding to it *)
     let code_e = compile_expr e in
     let pre, post = if fpmax > 0 then pushn fpmax, popn fpmax else nop, nop in
     code ++
     label (getLabel x) ++
     comment x ++
     push ra ++
     push fp ++
     move fp sp ++
     pre ++
     code_e ++
     post ++
     pop fp ++
     pop ra ++
     jr ra
     , 
     data

let initLabels =
   List.iter (function C.Let (x,_) | C.Letfun (x,_,_) -> 
           addLabel x)

let compile_program (p : C.decl list) ofile =
   C.print_prog p;
   initLabels p; (* fills in table genv *)
   let baseFuncCode, baseFuncData = baseFunctions () in
   let codefun, datafun = List.fold_left compile_decl (nop, nop) p in
   let p =
     { text =
        label "main" ++ (* in main, we just force the evaluation of "main" *)
        la a0 alab (getLabel "main") ++
        jal force ++
        li v0 17 ++ (* exits with exit code 0 *)
        li a0 0 ++
        syscall ++
        baseFuncCode ++
        codefun;
        data =
        baseFuncData ++
        datafun
     }
   in
   let f = open_out ofile in
   let fmt = Format.formatter_of_out_channel f in
   Mips.print_program fmt p;
   F.fprintf fmt "@?";
   close_out f
