module C = Closured
open Mips

(* a label generated by the compiler is of the forme bi where i is an integer 
 * getNextLabel () returns the next free label *)

let nextNbLabels = ref 1

let getNextLabel () =
   incr nextNbLabels;
   "b" ^ (string_of_int !nextNbLabels)

let force = ref 0

let forceGen () =
   (* force forces the evaluation of the value
    * contained inside a1 *)
   let force_1 = getNextLabel () and force_2 = getNextLabel () in
   label !force ++
   lw t0 areg (0,a0)++
   bgt t0 4 force_1 ++
   jr ra ++
   
   label force_1 ++
   li t1 3 ++
   beq t0 t1 force_2 ++
   lw a0 areg (4,a0) ++
   jr ra ++

   label force_2 ++
   push a0 ++
   push ra ++
   lw a1 areg (4,a0) ++
   lw t0 areg (4,a1) ++
   jalr t0 ++
   move a0 v0 ++
   jal force ++
   lw a1 areg (4,sp) ++
   sw a0 areg (4,a1) ++
   li t0 4 ++
   sw t0 areg (0,a1) ++
   lw ra areg (0,sp) ++
   popn 8 ++
   jr ra, nop

let putCharGen () =
   let putCharFun = getNextLabel () in
   (* prints the character inside $a0, it ignores $a1:
    * it is the function associated with putChar's closure *)
   (label putCharFun ++
   push fp ++
   push ra ++
   jal !force ++
   li v0 11 ++
   push a0 ++
   lw a0 areg (4, a0) ++
   syscall ++
   pop a0 ++
   pop ra ++
   pop fp ++
   jr ra),
   (label "putChar" ++
   dword [2] ++
   address [putCharFun])

let errorGen () =
   let errorFun = getNextLabel () in
   (
     let printChar = getNextLabel () in
     label errorFun ++
     lw t0 areg (0, a0) ++
     beqz t0 printChar ++
     li v0 17 ++ (* exit2 systemcall *)
     li a0 1 ++
     syscall ++
     label printChar ++
     move t0 a0 ++
     lw a0 areg (4,t0) ++
     li v0 11 ++
     syscall ++
     lw a0 areg (8,t0) ++
     j errorFun
   ),
   (label "error" ++
   dword [2] ++
   address [errorFun])

(* op is from mips module: div or rem *)
let opGen op () =
   let fun1 = getNextLabel () in
   let fun2 = getNextLabel () in
   (
      label fun1 ++
      push a0 ++
      li a0 12 ++
      li v0 9 ++
      syscall ++
      pop a0 ++
      li t0 2 ++
      sw t0 areg (0,v0) ++
      la t0 fun2 ++
      sw t0 areg (4,v0) ++
      sw a0 areg (8,v0) ++
      jr ra

      label fun2 ++
      jal !force ++ (* evaluates the second argument *)
      push a0 ++
      lw a0 areg (0,a1) ++ (* gets the first argument *)
      jal !force ++
      pop a1 ++
      (match op with "div" -> div | "rem" -> rem
                   | _ -> failwith "impossible case") v0 a1 a0
      jr ra
   ),
   (label op ++
   dword [2] ++
   address [fun1])

let baseFunctions () =
   List.fold_left (fun (code,data) f ->
      let code',data' = f () in
      (code ++ code'), (data ++ data')
   )
   [forceGen; putCharGen; errorGen; divGen "div"; remGen "rem"]

let compile_expr = function
 | C.Evar v -> 
     begin match v with
     | Vglobal x -> la v0 x
     | Vlocal i ->
        lw v0 areg (n*4, fp)
     | Vclos n ->
        lw v0 areg ((n+1)*4, a1)
     | Varg -> 
        move v0 a0 (* the current functions argument is in a0 *)
     end
 | C.Eclos (f,vs) ->
     push a0 ++
     li a0 (4*((List.length vs) + 8)) ++
     li v0 9 ++
     syscall ++
     la t0 f ++
     sw t0 areg (4,v0) ++
     la t0 2 ++
     sw t0 areg (0,v0) ++
     List.fold_left 
       (function
        | Vglobal x -> la v0 x
       )
       vs
     pop a0
 | C.Eapp (e1,e2) ->
     let code_e1 = compile_expr e1
     and code_e2 = compile_expr e2 in
     code_e1 ++
     move a1 v0 ++
     code_e2 ++
     move a0 v0 ++
     lw t0 areg (0,a1) ++
     jalr t0
 | C.Ethunk e -> (* according to the preceding module, e will always
                    be a closure *)
     let code_e = compile_expr e in
     code_e ++
     move t0 v0 ++
     li a0 8 ++
     li v0 9 ++
     syscall ++
     sw t0 (4,v0) ++
 | C.Elet (bs,e) ->
     (List.fold_left
       (fun acc (i,e') ->
          acc ++
          compile_expr e' ++
          sw v0 areg (i,fp))
       nop
       bs) ++
     compile_expr e
 | C.Eif (e1,e2,e3) ->
     let code_e1 = compile_expr e1
     and code_e2 = compile_expr e2
     and code_e3 = compile_expr e3 in
     let else_lab = nextElse () and endif_lab = nextEndIf () in
     code_e1 ++
     lw t0 areg (4,v0) ++
     beqz t0 else_lab ++
     code_e2 ++
     j endif_lab ++
     label else_lab ++
     code_e3 ++
     label endif_lab (* v0 already contains the good value *)
 | C.Ecase (e1,e2,i1,i2,e3) -> failwith "undefined"
 | C.Edo es ->
     List.fold_left (++) (List.map (compile_expr es)) nop
 | C.Ereturn -> nop
 | C.Eneg ->
     jal force ++
     li t0 0 ++
     sub a0 t0 oreg a0
 | C.EbinOp (e1,o,e2) when o <> C.colon -> 
     let code_e1 = code_expr e1 in
     let code_e2 = code_expr e2 in
     push a0 ++
     code_e1 ++
     move a0 v0 ++
     jal force ++
     move a0 a1 ++
     code_e2 ++
     pop a0
 | C.Etrue ->
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 1 ++
     sw t0 areg (4,v0) ++
     li t0 3 ++
     sw t0 areg (0,v0) ++
     move a0 v0
 | C.Efalse ->
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 0 ++
     sw t0 areg (4,v0) ++
     li t0 3 ++
     sw t0 areg (0,v0) ++
     move a0 v0
 | C.Eint n ->
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 n ++
     sw t0 areg (4,v0) ++
     li t0 0 ++
     sw t0 areg (0,v0) ++
     move a0 v0
 | C.Echar c ->
     li a0 8 ++
     li v0 9 ++
     syscall ++
     "li $t0, 'c'" ++
     sw t0 areg (4,v0) ++
     li t0 1 ++
     sw t0 areg (0,v0) ++
     move a0 v0
 | C.EemptyList ->
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 0 ++
     sw t0 areg (4,v0) ++
     li t0 0 ++
     sw t0 areg (0,v0) ++
     move a0 v0

and compile_binop o e1 e2 = failwith "undefined"

and compile_decl (codefun, codemain) = function
 | C.Let (x,e) ->
     let code_e = compile_expr e in
     label x ++
     push ra ++
     push fp ++
     move fp sp ++
     code_e ++
     pop fp ++
     pop ra ++
     jr ra
 | C.Letfun (x,e) ->
     let code_e = compile_expr e in
     label x ++
     push ra ++
     push fp ++
     move fp sp ++
     code_e ++
     pop fp ++
     pop ra ++
     jr ra

let initNbLabel p =
   let regexLabel = Str.regex "^b[1-9][0-9]*$" in
   List.iter (fun (x,e) -> 
        if Str.string_match regexLabel x 0
        then begin
           nextNbLabels := 
               max !nextNbLabels 
               ((string_of_int String.sub 1 (String.length x - 1)) + 1)
        end) p;
   force := getNextLabel ()

let compile_program p ofile =
   initNbLabel p; (* make sure we won't overwrite any of the function's label *)
   let codefun, code = List.fold_left compile_decl (nop, nop) p in
   let p =
     { text =
        baseFunctions ++
        codefun
       data =
        label "div" ++
        dword [2] ++
        address ["fun2"] ++
        label "rem" ++
        dword [2] ++
        address ["fun4"]
     }
   in
   let f = open_out ofile in
   let fmt = Format.formatter_of_out_channel f in
   Mips.print_program fmt p;
   fprint fmt "@?";
   close_out f
