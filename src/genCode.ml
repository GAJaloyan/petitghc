module C = Closured
module F = Format
open Mips

(* a label generated by the compiler is of the forme bi where i is an integer 
 * getNextLabel () returns the next free label *)

let nextNbLabels = ref 0

let getNextLabel () =
   incr nextNbLabels;
   "_l" ^ (string_of_int !nextNbLabels)

let force = "_force"

let forceGen () =
   (* force forces the evaluation of the value
    * contained inside a0 *)
   let force_1 = "_force_1" and force_2 = "_force_2" in
   comment "start force" ++
   label force ++
   lw t0 areg (0,a0)++
   li t1 2 ++
   bgt t0 t1 "_force_1" ++
   jr ra ++
   
   label force_1 ++
   li t1 3 ++
   beq t0 t1 force_2 ++
   lw a0 areg (4,a0) ++
   jr ra ++

   label force_2 ++
   push ra ++
   push a0 ++
   lw a1 areg (4,a0) ++
   lw t0 areg (4,a1) ++
   jalr t0 ++
   move a0 v0 ++
   jal force ++
   pop a1 ++
   sw a0 areg (4,a1) ++
   li t0 4 ++
   sw t0 areg (0,a1) ++
   pop ra ++
   jr ra ++
   comment "end force"
   ,
   nop

let putCharGen () =
   (* prints the character inside $a0, it ignores $a1:
    * it is the function associated with putChar's closure *)
   (comment "start putChar" ++
   label "_putCharFun" ++
   push fp ++
   push ra ++
   push a0 ++
   push a1 ++
   move a0 a2 ++
   jal force ++
   li v0 11 ++
   lw a0 areg (4, a0) ++
   syscall ++
   pop a1 ++
   pop a0 ++
   pop ra ++
   pop fp ++
   (* returns zero for IO () *)
   push a0 ++
   li a0 8 ++
   li v0 9 ++
   syscall ++
   li t0 0 ++
   sw t0 areg (4,v0) ++
   li t0 0 ++
   sw t0 areg (0,v0) ++
   pop a0 ++
   jr ra ++
   comment "end putChar")
   ,
   (label "putChar" ++
   dword [2] ++
   address ["_putCharFun"])

let errorGen () =
   let errorFun = getNextLabel () in
   (
     let printChar = getNextLabel () in
     comment "start error" ++
     label errorFun ++
     lw t0 areg (0, a0) ++
     beqz t0 printChar ++
     li v0 17 ++ (* exit2 systemcall *)
     li a0 1 ++
     syscall ++
     label printChar ++
     move t0 a0 ++
     lw a0 areg (4,t0) ++
     li v0 11 ++
     syscall ++
     lw a0 areg (8,t0) ++
     j errorFun ++
     comment "end error"
   ),
   (label "error" ++
   dword [2] ++
   address [errorFun])

(* op is from mips module: div or rem *)
let opGen op () =
   let fun1 = getNextLabel () in
   let fun2 = getNextLabel () in
   (
      comment ("start " ^ op) ++
      label fun1 ++
      push a0 ++
      li a0 12 ++
      li v0 9 ++
      syscall ++
      pop a0 ++
      li t0 2 ++
      sw t0 areg (0,v0) ++
      la t0 alab fun2 ++
      sw t0 areg (4,v0) ++
      sw a0 areg (8,v0) ++
      jr ra ++

      label fun2 ++
      jal force ++ (* evaluates the second argument *)
      push a0 ++
      lw a0 areg (0,a1) ++ (* gets the first argument *)
      jal force ++
      pop a1 ++
      (match op with "div" -> div | "rem" -> rem
                   | _ -> failwith "impossible case") v0 a1 oreg a0 ++
      jr ra ++
      comment ("end " ^ op)
   ),
   (label op ++
   dword [2] ++
   address [fun1])

let baseFunctions () =
   List.fold_left (fun (code,data) f ->
      let code',data' = f () in
      (code ++ code'), (data ++ data')
   )
   (nop,nop)
   [forceGen; putCharGen; errorGen; opGen "div"; opGen "rem"]

let rec compile_expr = function
 | C.Evar v -> 
     begin match v with
     | C.Vglobal x -> la v0 alab x
     | C.Vlocal i ->
        lw v0 areg (i, fp)
     | C.Vclos n ->
        lw v0 areg (n, a1)
     | C.Varg -> 
        move v0 a2 (* the current functions argument is in a0 *)
     end

 | C.Eclos (f,vs) ->
     comment ("startclos" ^ f) ++

     (* allocates the closure *)
     push a0 ++
     li a0 (4*(List.length vs)+8) ++
     li v0 9 ++
     syscall ++
     pop a0 ++

     la t0 alab f ++
     sw t0 areg (4,v0) ++
     li t0 2 ++
     sw t0 areg (0,v0) ++
     fst (
       List.fold_left 
       (fun (acc,posClos) v ->
        (acc ++
         (match v with 
         | C.Vglobal x -> la t0 alab x 
         | C.Vlocal n  -> lw t0 areg (n, fp) 
         | C.Vclos n   -> lw t0 areg (n, a1) 
         | C.Varg      -> move t0 a2
        ) ++ sw t0 areg (posClos, v0)),
        (posClos+4)
       )
       (nop,8)
       vs) ++
     comment ("endClos" ^ f)

 | C.Eapp (e1,e2) ->
     (* should be good *)
     let code_e1 = compile_expr e1
     and code_e2 = compile_expr e2 in
     comment "start app" ++
     push ra ++
     code_e1 ++
     push a0 ++
     push a1 ++
     move a0 v0 ++
     jal force ++
     move t0 a0 ++
     pop a1 ++
     pop a0 ++
     push t0 ++ (* closure on top of the stack *)

     code_e2 ++
     push a0 ++
     push a1 ++
     move a0 v0 ++
     jal force ++
     move t0 a0 ++ (* argument in t0 *)
     pop a1 ++
     pop a0 ++
     pop t1 ++ (* closure in t1 *)
     push a2 ++
     push a1 ++
     push a0 ++
     move a1 t1 ++
     move a2 t0 ++
     lw t0 areg (4,a1) ++
     jalr t0 ++
     pop a0 ++
     pop a1 ++
     pop a2 ++
     pop ra ++
     comment "end app"

 | C.Ethunk e -> (* according to the preceding module, e will always
                    be a closure *)
     (* should be good *)
     let code_e = compile_expr e in
     comment "start thunk" ++
     push a0 ++
     code_e ++
     move t0 v0 ++
     li a0 8 ++ (* allocates 2 places in memory *)
     li v0 9 ++
     syscall ++
     sw t0 areg (4,v0) ++
     li t0 3 ++
     sw t0 areg (0,v0) ++
     pop a0 ++
     comment "end thunk"

 | C.Elet (bs,e) ->
     comment "begin let in" ++
     (List.fold_left
       (fun acc (i,e') ->
          acc ++
          compile_expr e' ++
          sw v0 areg (i,fp))
       nop
       bs) ++
     compile_expr e ++
     comment "end let in"

 | C.Eif (e1,e2,e3) ->
     let code_e1 = compile_expr e1
     and code_e2 = compile_expr e2
     and code_e3 = compile_expr e3 in
     let else_lab = getNextLabel () and endif_lab = getNextLabel () in
     comment "begin if" ++
     code_e1 ++
     push ra ++
     push a0 ++
     push a1 ++
     move a0 v0 ++
     jal force ++
     move v0 a0 ++
     pop a1 ++
     pop a0 ++
     pop ra ++
     lw t0 areg (4,v0) ++
     beqz t0 else_lab ++
     comment "begin then" ++
     code_e2 ++
     j endif_lab ++
     comment "begin else" ++
     label else_lab ++
     code_e3 ++
     label endif_lab (* v0 already contains the good value *)

 | C.Ecase (e1,e2,i1,i2,e3) ->
     let code_e1 = compile_expr e1 in
     let code_e2 = compile_expr e2 in
     let code_e3 = compile_expr e3 in
     let case_branch2 = getNextLabel () in
     let case_end = getNextLabel () in
     comment "begin case" ++
     code_e1 ++
     push ra ++
     push a1 ++
     push a0 ++
     move a0 v0 ++
     jal force ++
     move v0 a0 ++
     pop a0 ++
     pop a1 ++
     pop ra ++
     lw t0 areg (0,v0) ++ (* if the result is 0 (empty list *)
     bnez t0 case_branch2 ++
     code_e2 ++
     j case_end ++
     label case_branch2 ++
     lw t0 areg (4,v0) ++ (* first element of cons *)
     sw t0 areg (i1,fp) ++
     lw t0 areg (8,v0) ++ (* second element of cons *)
     sw t0 areg (i2,fp) ++
     code_e3 ++
     label case_end ++
     comment case_end

 | C.Edo es ->
     let ces = List.map compile_expr es in
     List.fold_left (fun acc x -> x ++ acc) nop ces

 | C.Ereturn ->
     push a0 ++
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 0 ++
     sw t0 areg (4,v0) ++
     li t0 0 ++
     sw t0 areg (0,v0) ++
     pop a0

 | C.Eneg e ->

     let code_e = compile_expr e in
     code_e ++
     move a0 v0 ++
     jal force ++
     li t0 0 ++
     sub v0 t0 oreg a0

 | C.EbinOp (e1,o,e2) -> 
     let code_e1 = compile_expr e1 in
     let code_e2 = compile_expr e2 in

     comment "begin EbinOp" ++
     push ra ++
     code_e1 ++
     push a0 ++
     push a1 ++
     move a0 v0 ++
     jal force ++
     move t0 a0 ++
     pop a1 ++
     pop a0 ++
     push t0 ++ (* result on top of the stack *)

     code_e2 ++
     push a0 ++
     push a1 ++
     move a0 v0 ++
     jal force ++
     move t0 a0 ++
     pop a1 ++
     pop a0 ++
     push t0 ++ (* second operand on top of the stack *)
     
     pop t3 ++ (* second operand *)
     lw t2 areg (4,t3) ++
     pop t3 ++ (* first operand *)
     lw t1 areg (4,t3) ++

     (let make_simple_val = 
        sw t0 areg (4,v0) ++
        li t0 0 ++
        sw t0 areg (0,v0)
      and alloc n = push a0 ++ li a0 n ++ li v0 9 ++
                    syscall ++ pop a0 in
     match o with
     | C.Plus      -> alloc 8 ++ add t0 t1 oreg t2 ++ make_simple_val
     | C.Minus     -> alloc 8 ++ sub t0 t1 oreg t2 ++ make_simple_val
     | C.Time      -> alloc 8 ++ mul t0 t1 oreg t2 ++ make_simple_val
     | C.LowerEq   -> alloc 8 ++ sle t0 t1 t2 ++ make_simple_val
     | C.GreaterEq -> alloc 8 ++ sge t0 t1 t2 ++ make_simple_val
     | C.Greater   -> alloc 8 ++ sgt t0 t1 t2 ++ make_simple_val
     | C.Lower     -> alloc 8 ++ slt t0 t1 t2 ++ make_simple_val
     | C.Unequal   -> alloc 8 ++ sne t0 t1 t2 ++ make_simple_val
     | C.Equal     -> alloc 8 ++ seq t0 t1 t2 ++ make_simple_val
     | C.And       -> alloc 8 ++ and_  t0 t1 t2 ++ make_simple_val
     | C.Or        -> alloc 8 ++ or_ t0 t1 t2 ++ make_simple_val
     | C.Colon     -> 
           alloc 12 ++ 
           sw t1 areg (4, v0) ++
           sw t2 areg (8, v0) ++
           li t0 1 ++
           sw t0 areg (0, v0)
     ) ++
     pop ra ++
     comment "end EbinOp"

 | C.Etrue ->
     push a0 ++
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 1 ++
     sw t0 areg (4,v0) ++
     li t0 0 ++
     sw t0 areg (0,v0) ++
     pop a0

 | C.Efalse ->
     push a0 ++
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 0 ++
     sw t0 areg (4,v0) ++
     li t0 0 ++
     sw t0 areg (0,v0) ++
     pop a0

 | C.Eint n ->
     push a0 ++
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 n ++
     sw t0 areg (4,v0) ++
     li t0 0 ++
     sw t0 areg (0,v0) ++
     pop a0

 | C.Echar c ->
     push a0 ++
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 (Char.code c) ++
     sw t0 areg (4,v0) ++
     li t0 0 ++
     sw t0 areg (0,v0) ++
     pop a0

 | C.EemptyList ->
     push a0 ++
     li a0 8 ++
     li v0 9 ++
     syscall ++
     li t0 0 ++
     sw t0 areg (4,v0) ++
     li t0 0 ++
     sw t0 areg (0,v0) ++
     pop a0

and compile_decl (code,data) = function
 | C.Let (x,e) ->
     let thunkLab = getNextLabel () in
     let funLab = getNextLabel () in
     let code_e = compile_expr e in
     code ++
     label funLab ++
     code_e ++
     jr ra
     ,
     (data ++
     label x ++
     dword [3] ++
     address [thunkLab] ++
     label thunkLab ++
     dword [2] ++
     address [funLab])

 | C.Letfun (x,e,fpmax) -> (* x is the name of the function
                              and e is the expression corresponding to it *)
     let code_e = compile_expr e in
     let pre, post = if fpmax > 0 then pushn fpmax, popn fpmax else nop, nop in
     code ++
     label x ++
     comment x ++
     push ra ++
     push fp ++
     move fp sp ++
     pre ++
     code_e ++
     post ++
     pop fp ++
     pop ra ++
     jr ra
     , 
     data

let compile_program (p : C.decl list) ofile =
   C.print_prog p;
   let baseFuncCode, baseFuncData = baseFunctions () in
   let codefun, datafun = List.fold_left compile_decl (nop, nop) p in
   let p =
     { text =
        label "main" ++ (* in main, we just force the evaluation of "main" *)
        la a0 alab "_main" ++
        jal force ++
        li v0 17 ++ (* exits with exit code 0 *)
        li a0 0 ++
        syscall ++
        baseFuncCode ++
        codefun;
        data =
        baseFuncData ++
        datafun
     }
   in
   let f = open_out ofile in
   let fmt = Format.formatter_of_out_channel f in
   Mips.print_program fmt p;
   F.fprintf fmt "@?";
   close_out f
