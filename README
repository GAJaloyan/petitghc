Compilation : Petit Haskell to MIPS
Ruggero Cyrille and Jaloyan Georges-Axel

This is my compilation project for the course on compilation at the ENS Paris. The goal
is to make a compiler for a portion of haskell, called Petit Haskell, producted in MIPS. It
contains only integers and lists and is 100% compatible with Haskell.

Lexical conventions: spaces, tabulations and newlines are considered as blank characters.
Comments start with a -- and end at the end of the line. The identifiers obey the
regular expression <indent> with is:

<digit> ::= 0-9
<alpha> ::= a-z | A-Z
<ident> ::= (a-z) (<alpha> | _ | ' | <digit>)*

In what follows, <ident_0> is the identifier placed in the first column and <ident_1> is
any other identifier.

The following identifiers are key words:
else - if - in - let - case - of - then - return - do

Finally, the litterals obey the following regular expressions:

<int> ::= <digit>+
<car> ::= any ASCII character whose code is in between 32 and 126 inclusive different then
          \ and "
<character> ::= '<car>'
<chain> ::= "<car>*"

The following grammar is the one of the source files. The input point is the non-terminal
<file>. The associativities and the precedences of the operators are given in this table,
from the weakest to the strongest:

|------------------------|---------------|
|Operator                | Associativity |
|------------------------|---------------|
| in                     |               |
| else                   |               |
| ->                     |               |
| ||                     | left          |
| &&                     | left          |
| < <= > >= == /=        | left          |
| :                      | right         |
| + -                    | left          |
| *                      | left          |
| - (unary)              |               |
| function application   | left          |
|------------------------|---------------|

<file> ::= <def_0>* EOF
<def_0> ::= <ident_0> <ident_1>* = <expr>
<def>   ::= <ident_1> <ident_1>* = <expr>
<simple_expr>   ::= ( <expr> ) | <ident_1> | <const> | [ <expr>_,*]
<expr>          ::= <simple_expr>+
                  | \ <ident_1>+ -> <expr>
                  | - <expr> | <expr> <op> <expr>
                  | if <expr> then <expr> else <expr>
                  | let <bindings> in <expr>
                  | case <expr> of { [ ] -> <expr>; <ident_1> : <ident_1> -> <expr> ;? }
                  | do { <expr>_;+;? }
                  | return ( )
<bindings>      ::= <def> | { <def>_;+;? }
<op>            ::= + | - | * | <= | >= | > | < | /= | == | && | || | :
<const>         ::= True | False | <int> | <caracter> | <chain>


The file is compiled as follows: putChar, error, rem and div are
always included in the object code. They are associated with 4
variables, each one containing an empty closure to these functions.
Next, the stack contains has many variables as there are global
definitions.



===========================================
Usage : 
make
./petitghc [options] [-o outputfile.s] inputfile.hs

Options :
--parse-only : parses the inputfile, then prints a graphviz code of the constructed ast on stdout, then exits.
--type-only : types the inputfile, then prints a graphviz code of the typed ast on stdout, then exits.
--simplify-only : simplifies the ast, then prints a graphviz code of the simplified ast on stdout, then exits.
-o : the output file if specified, else set to inputfile.s

Needed :
ocaml version 4.02.1
dot - graphviz version 2.36.0
rsync version 3.1.0

============================================
[À traduire en anglais] Difficultés :


La principale difficulté a été la nouveauté des outils, en plus des quelques détails spécifiques au sujet :

- Le lexer / parser a été un peu revu pour adapter la forme de l'ast (transformations du type def0 a b c = e --> def0 = \ a b c -> e), et stocker les informations de localisation de façon plus précise. 
- Le typage a été fait en grande partie grâce au TD 4, la gestion des erreurs a été faite de façon rigoureuse (pour se rapprocher de celle d'Ocaml), avec un morceau de code du cours de Système digital adapté pour afficher proprement les erreurs.

